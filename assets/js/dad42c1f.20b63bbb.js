"use strict";(globalThis.webpackChunkphysical_ai_robotics_textbook=globalThis.webpackChunkphysical_ai_robotics_textbook||[]).push([[762],{660:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var t=n(8168),r=(n(6540),n(5680));const i={id:"03-python-rclpy-integration",title:"Chapter 3: Building Applications with rclpy",sidebar_label:"3. Building with rclpy"},o=void 0,l={unversionedId:"03-python-rclpy-integration",id:"03-python-rclpy-integration",title:"Chapter 3: Building Applications with rclpy",description:"Chapter 3: Building Applications with rclpy",source:"@site/docs/03-python-rclpy-integration.md",sourceDirName:".",slug:"/03-python-rclpy-integration",permalink:"/AI-driven-development/docs/03-python-rclpy-integration",draft:!1,editUrl:"https://github.com/ai-driven-development/AI_Robotics_book/tree/main/docs/03-python-rclpy-integration.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"03-python-rclpy-integration",title:"Chapter 3: Building Applications with rclpy",sidebar_label:"3. Building with rclpy"},sidebar:"tutorialSidebar",previous:{title:"2. Nodes, Topics, & Actions",permalink:"/AI-driven-development/docs/02-ros2-nodes-topics-services"},next:{title:"4. URDF for Humanoids",permalink:"/AI-driven-development/docs/04-urdf-for-humanoids"}},p={},s=[{value:"Chapter 3: Building Applications with rclpy",id:"chapter-3-building-applications-with-rclpy",level:2},{value:"3.1 The ROS 2 Workspace and Package Structure",id:"31-the-ros-2-workspace-and-package-structure",level:3},{value:"Creating a Python Application Package",id:"creating-a-python-application-package",level:4},{value:"Creating a Custom Interface Package",id:"creating-a-custom-interface-package",level:4},{value:"Building the Workspace",id:"building-the-workspace",level:4},{value:"3.2 Writing a Custom Node with <code>rclpy</code>",id:"32-writing-a-custom-node-with-rclpy",level:3},{value:"3.3 Advanced Parameter Management",id:"33-advanced-parameter-management",level:3},{value:"Using YAML for Parameters",id:"using-yaml-for-parameters",level:4},{value:"3.4 Python Launch Files",id:"34-python-launch-files",level:3}],c={toc:s},g="wrapper";function d({components:e,...a}){return(0,r.yg)(g,(0,t.A)({},c,a,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h2",{id:"chapter-3-building-applications-with-rclpy"},"Chapter 3: Building Applications with rclpy"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Objective"),": Master the creation of custom ROS 2 packages, nodes, and launch files using the ",(0,r.yg)("inlineCode",{parentName:"p"},"rclpy")," (ROS Client Library for Python) library."),(0,r.yg)("h3",{id:"31-the-ros-2-workspace-and-package-structure"},"3.1 The ROS 2 Workspace and Package Structure"),(0,r.yg)("p",null,"Before writing code, it's crucial to understand how ROS 2 organizes projects. All your code should live within a ",(0,r.yg)("strong",{parentName:"p"},"workspace"),", which is essentially a directory containing your ROS 2 packages. A typical workspace has the following structure:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"ros2_ws/")," (your workspace root)",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"src/"),": This is where you place the source code for all your ROS 2 packages."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"build/"),": An intermediate directory where ",(0,r.yg)("inlineCode",{parentName:"li"},"colcon")," (the ROS 2 build tool) processes your packages."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"install/"),": The final destination for your built packages, including executables and setup files."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"log/"),": Contains logs from the build process.")))),(0,r.yg)("h4",{id:"creating-a-python-application-package"},"Creating a Python Application Package"),(0,r.yg)("p",null,"A ROS 2 ",(0,r.yg)("strong",{parentName:"p"},"Package")," is a directory containing your nodes, launch files, interface definitions, and a manifest file. It's the fundamental unit of software organization in ROS. For a Python-based application, we create an ",(0,r.yg)("inlineCode",{parentName:"p"},"ament_python")," package."),(0,r.yg)("p",null,"From within your ",(0,r.yg)("inlineCode",{parentName:"p"},"ros2_ws/src")," directory, run:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"ros2 pkg create --build-type ament_python --node-name battery_monitor my_robot_app\n")),(0,r.yg)("p",null,"This creates a package named ",(0,r.yg)("inlineCode",{parentName:"p"},"my_robot_app")," with a sample node named ",(0,r.yg)("inlineCode",{parentName:"p"},"battery_monitor"),". Let's examine the key generated files:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"package.xml"),": The package manifest. It contains meta-information like the package name, version, author, and, most importantly, its dependencies. For example, you must list which other ROS 2 packages you ",(0,r.yg)("inlineCode",{parentName:"li"},"depend")," on."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"setup.py"),": The Python setup script. Its primary role is to define the ",(0,r.yg)("inlineCode",{parentName:"li"},"entry_points")," for your nodes. This is how ROS 2 knows that a name like ",(0,r.yg)("inlineCode",{parentName:"li"},"battery_monitor")," corresponds to a function in a specific Python file, making it an executable."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"setup.cfg"),": A configuration file for ",(0,r.yg)("inlineCode",{parentName:"li"},"setup.py"),".")),(0,r.yg)("h4",{id:"creating-a-custom-interface-package"},"Creating a Custom Interface Package"),(0,r.yg)("p",null,"A core principle of ROS is ",(0,r.yg)("strong",{parentName:"p"},"separating interfaces from implementation"),". Your custom message, service, and action definitions should live in their own dedicated package. This package must be a ",(0,r.yg)("inlineCode",{parentName:"p"},"ament_cmake")," package, even if you are only using it with Python nodes."),(0,r.yg)("p",null,"From ",(0,r.yg)("inlineCode",{parentName:"p"},"ros2_ws/src"),", create a second package for our interfaces:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"ros2 pkg create --build-type ament_cmake my_robot_interfaces\n")),(0,r.yg)("p",null,"This package requires special configuration:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"In ",(0,r.yg)("inlineCode",{parentName:"strong"},"package.xml")),", you must add dependencies that give your package the ability to generate code from interface files:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-xml"},"<buildtool_depend>rosidl_default_generators</buildtool_depend>\n<depend>rosidl_default_runtime</depend>\n<member_of_group>rosidl_interface_packages</member_of_group>\n"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"In ",(0,r.yg)("inlineCode",{parentName:"strong"},"CMakeLists.txt")),", you must tell the build system to find the generator and which files to turn into code:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-cmake"},'find_package(rosidl_default_generators REQUIRED)\n\nrosidl_generate_interfaces(${PROJECT_NAME}\n  "msg/BatteryState.msg"\n)\n'))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"In ",(0,r.yg)("inlineCode",{parentName:"strong"},"my_robot_app/package.xml")),", you must add a dependency on your new interface package:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-xml"},"<depend>my_robot_interfaces</depend>\n")))),(0,r.yg)("p",null,"Now, create a ",(0,r.yg)("inlineCode",{parentName:"p"},"msg")," directory inside ",(0,r.yg)("inlineCode",{parentName:"p"},"my_robot_interfaces")," and add the following file:"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("inlineCode",{parentName:"strong"},"my_robot_interfaces/msg/BatteryState.msg"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"std_msgs/Header header\nfloat32 voltage\nfloat32 percentage\nbool is_charging\n")),(0,r.yg)("h4",{id:"building-the-workspace"},"Building the Workspace"),(0,r.yg)("p",null,"To build your packages, navigate to the root of your workspace (",(0,r.yg)("inlineCode",{parentName:"p"},"ros2_ws"),") and run:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"colcon build\n")),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"colcon")," will automatically discover your packages and build them in the correct order, building ",(0,r.yg)("inlineCode",{parentName:"p"},"my_robot_interfaces")," first. After a successful build, you must source the new setup file in the ",(0,r.yg)("inlineCode",{parentName:"p"},"install")," directory to make your new packages and messages available in your terminal:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"source install/setup.bash\n")),(0,r.yg)("h3",{id:"32-writing-a-custom-node-with-rclpy"},"3.2 Writing a Custom Node with ",(0,r.yg)("inlineCode",{parentName:"h3"},"rclpy")),(0,r.yg)("p",null,"Let's rewrite our ",(0,r.yg)("inlineCode",{parentName:"p"},"battery_monitor")," node to use our new custom message. Using a class that inherits from ",(0,r.yg)("inlineCode",{parentName:"p"},"rclpy.node.Node")," is the standard way to structure a node, as it helps manage state and organize communication callbacks."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"# In my_robot_app/my_robot_app/battery_monitor.py\nimport rclpy\nfrom rclpy.node import Node\nfrom my_robot_interfaces.msg import BatteryState # Import our custom message\n\nclass BatteryMonitorNode(Node):\n    def __init__(self):\n        super().__init__('battery_monitor')\n        # Note the change from Float32 to BatteryState\n        self.publisher_ = self.create_publisher(BatteryState, 'battery_level', 10)\n        self.timer = self.create_timer(1.0, self.publish_battery_level)\n        self.battery_level_ = 100.0\n        self.get_logger().info('Battery Monitor node started.')\n\n    def publish_battery_level(self):\n        # Create an instance of our custom message\n        msg = BatteryState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.voltage = 12.5 - ( (100.0 - self.battery_level_) / 100.0 * 2.5 )\n        msg.percentage = self.battery_level_\n        msg.is_charging = False\n        \n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing battery level: {self.battery_level_:.2f}%')\n        self.battery_level_ -= 0.1\n        if self.battery_level_ < 0:\n            self.battery_level_ = 100.0\n")),(0,r.yg)("h3",{id:"33-advanced-parameter-management"},"3.3 Advanced Parameter Management"),(0,r.yg)("p",null,"Hardcoding values like the battery drain rate is bad practice. Parameters make your nodes reusable and configurable."),(0,r.yg)("p",null,(0,r.yg)("em",{parentName:"p"},"[Image: A diagram showing the parameter override hierarchy. A value from a YAML file is overridden by a value in a launch file, which is in turn overridden by a value from the command line (",(0,r.yg)("inlineCode",{parentName:"em"},"ros2 param set"),").]")),(0,r.yg)("p",null,"Let's add a parameter for the drain rate and a dynamic callback to update it on the fly."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"# In my_robot_app/my_robot_app/battery_monitor.py, updated __init__\ndef __init__(self):\n    super().__init__('battery_monitor')\n    \n    # Declare the parameter and its default value\n    self.declare_parameter('drain_rate', 0.1)\n    \n    # Get the initial value\n    self.drain_rate_ = self.get_parameter('drain_rate').get_parameter_value().double_value\n    \n    # Add a callback for when parameters are changed\n    self.add_on_set_parameters_callback(self.parameter_callback)\n\n    # ... (rest of __init__)\n\n# Add the callback method to the class\ndef parameter_callback(self, params):\n    for param in params:\n        if param.name == 'drain_rate':\n            self.drain_rate_ = param.value\n            self.get_logger().info(f'Drain rate updated to: {self.drain_rate_}')\n    return rclpy.parameter.Parameter.SetParametersResult(successful=True)\n")),(0,r.yg)("p",null,"Now, you can change the drain rate while the node is running with the command:\n",(0,r.yg)("inlineCode",{parentName:"p"},"ros2 param set /battery_monitor drain_rate 0.5")),(0,r.yg)("h4",{id:"using-yaml-for-parameters"},"Using YAML for Parameters"),(0,r.yg)("p",null,"For complex systems, you should store parameters in a YAML file."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("inlineCode",{parentName:"strong"},"my_robot_app/config/params.yaml"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},"battery_monitor:\n  ros__parameters:\n    drain_rate: 0.2\n")),(0,r.yg)("h3",{id:"34-python-launch-files"},"3.4 Python Launch Files"),(0,r.yg)("p",null,"Launch files are Python scripts that allow you to start and configure a complex system of multiple nodes at once. They are the standard way to run a ROS 2 application."),(0,r.yg)("p",null,"Let's create a launch file that starts our battery monitor and loads its parameters from our YAML file."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"# In my_robot_app/launch/my_launch.launch.py\nimport os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    # Get the path to our parameter file\n    config = os.path.join(\n        get_package_share_directory('my_robot_app'),\n        'config',\n        'params.yaml'\n    )\n\n    return LaunchDescription([\n        Node(\n            package='my_robot_app',\n            executable='battery_monitor',\n            name='battery_monitor',\n            parameters=[config] # Pass the config file to the node\n        ),\n        # You could add other nodes here\n    ])\n")),(0,r.yg)("p",null,"You would then need to update ",(0,r.yg)("inlineCode",{parentName:"p"},"setup.py")," to tell ROS 2 where to find this launch file. Finally, you can run everything with a single command:\n",(0,r.yg)("inlineCode",{parentName:"p"},"ros2 launch my_robot_app my_launch.launch.py")),(0,r.yg)("p",null,"This chapter provides the foundational skills for creating complete, configurable, and reusable ROS 2 applications with Python."))}d.isMDXComponent=!0},5680:(e,a,n)=>{n.d(a,{xA:()=>c,yg:()=>m});var t=n(6540);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),n.push.apply(n,t)}return n}function o(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach(function(a){r(e,a,n[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))})}return e}function l(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=t.createContext({}),s=function(e){var a=t.useContext(p),n=a;return e&&(n="function"==typeof e?e(a):o(o({},a),e)),n},c=function(e){var a=s(e.components);return t.createElement(p.Provider,{value:a},e.children)},g="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},y=t.forwardRef(function(e,a){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),g=s(n),y=r,m=g["".concat(p,".").concat(y)]||g[y]||d[y]||i;return n?t.createElement(m,o(o({ref:a},c),{},{components:n})):t.createElement(m,o({ref:a},c))});function m(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=y;var l={};for(var p in a)hasOwnProperty.call(a,p)&&(l[p]=a[p]);l.originalType=e,l[g]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}y.displayName="MDXCreateElement"}}]);